<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
            <style>
                code {
                    tab-size: 4;
					-moz-tab-size: 4;
                }
            </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Functional Programming 101</h1>
					From Functions to Monads
					<p>
						There's only 1 real solution to program complexity:
						abstraction.
					</p>
					<aside class="notes">
						Hi, I'm Rob. Please feel free to interrupt at any point
						if you have questions. Also, if you have a webcam, I
						would appreciate if you turned it on so I can look over
						to my second monitor and see if people look confused,
						bored, or otherwise. Please ask questions over the mic,
						I'm not a good enough multitasker to give a talk and
						also read the chat.
					</aside>
				</section>
				<section>
					What is functional programming?
					<p class="fragment">
						Functional programming is a style that emphasizes functions.
					</p>
					<pre><code data-trim class="js">
						function sum(a, b) {
							return a + b;
						}
					</code></pre>
					<aside class="notes">
						This might be astonishing, but...
					</aside>
				</section>
				<section>
					Why should you care?
					<p class="fragment">
						Nearly every single major programming language has
						recently incorporated ideas from functional programming.
					</p>
					<p class="fragment">
						Also, many of the fundamental ideas of functional
						programming are just good practices that you should
						follow anyway.
					</p>
					<aside class="notes">
						<p>
							Ask if there are any functional programming gurus.
							Say there will be something for everyone in this
							talk. 
						</p>
						<p>
							Let's get into it.
						</p>
					</aside>
				</section>
				<section>
					<p>
						Here is some JavaScript.
					</p>
					<p class="fragment">
						Can we say with certainty what this code will do?
					</p>
					<pre><code data-trim class="js">
						// import our library
						const { get_data } = require("./lib.js");

						// warn the user about the perils of global variables
						message = "Avoid global variables!";
						console.log(message);

						// get some data for later
						data = get_data();

						// warn them again just to be sure
						console.log(message);
					</code></pre>
					<aside class="notes">
						<p>
							Definitely following best practices...
						</p>
						<p>
							To demo from here.
						</p>
					</aside>
				</section>
				<section>
					Why was my library code so evil?
					<p class="fragment">
						In short, <strong>state</strong>. State is just anything
						that can change. When things can change out from under
						you after any function call or member access, it becomes
						basically impossible to be certain of the state of the
						system at any given time.
					</p>
					<aside class="notes">
						My very scientific definition of state.
					</aside>
				</section>
				<section>
					Why?
					<p class="fragment">
						Psychological studies have actually shown that humans
						are only capable of keeping 7 Â± 2 objects in short term
						memory at a time.
					</p>
					<p class="fragment">
						<strong>Stateful programming doesn't scale.</strong>
						Once your application has portions of code that have 10,
						11, or 12 variables, you become <strong>physically
						incapable</strong> of keeping track of everything.
					</p>
					<aside class="notes">
						Have you ever noticed that when you start a project, you
						really feel like you're getting things done, but once
						you've been working on it for a while, progress slows
						down dramatically and you spend more time fixing bugs
						than adding features? 

						<p>
							Some people go as far to say that state is the root
							of all evil.
						</p>
					</aside>
				</section>
				<section>
					<section>
						In functional programming, we outlaw state.
						<!-- image of state crossed out -->
						<p class="fragment">
							Once we initialize a "variable", we never change it
							again. This is called <strong>immutability</strong>,
							because we can't mutate (or change) the state.
						</p>
						<p class="fragment">
							In JavaScript, this means we should use
							<code>const</code> everywhere.
						</p>
						<pre><code data-trim class="js">
							const message = "Functional programming is great!";
						</code></pre>
					</section>
					<section>
						Unfortunately, <code>const</code> doesn't actually make
						things completely immutable in JavaScript.
						<pre><code data-trim class="js">
							const weather_states = ["sunny", "rainy"];
							weather_states.push("overcast");
							console.log(weather_states);
							// ["sunny", "rainy", "overcast"]
							// :(
						</code></pre>
					</section>
					<section>
						<code>const</code> prevents you from setting the
						variable to a new array or object, but it doesn't stop
						you from modifying the array or object itself.
						<pre><code data-trim class="js">
							const weather_states = ["sunny", "rainy"];
							weather_states.push("overcast");
							console.log(weather_states);
							// ["sunny", "rainy", "overcast"]
							// :(
							weather_states = ["cloudy"]; // this will not work
						</code></pre>
					</section>
					<section>
						In short, use <code>const</code> whenever you can, but
						be aware of its limitations.
					</section>
				</section>
				<section>
					Immutable data is great for our functions. Since nothing can
					ever change, we don't have to worry that a function call has
					gone and messed things up behind our back.
					<pre class="fragment"><code data-trim class="js">
							function calculate_something(a, b) { ... }
							function get_data() { ... }

							const one = calculate_something(1, "hello");

							const data = get_data();

							// we know for sure this will be the same
							const two = calculate_something(1, "hello");
					</code></pre>
					<aside class="notes">
						There's another great thing about this: if we call a
						function with the same arguments, we are guaranteed to
						get the same result.
					</aside>
				</section>
				<section>
					Functional programming also has a notion of
					<strong>side effects</strong>.
					<p class="fragment">
						Side effects are things like writing to a file, reading
						input, and other I/O operations. These are also outlawed
						in functional programming, because they can behave like
						another kind of state.
					</p>
					<pre class="fragment"><code data-trim class="js">
						// not allowed in pure functional programming
						function add_and_print(a, b) {
							console.log(a + b);
						}
					</code></pre>
				</section>
				<section>
					But Rob: if we can't change anything, print anything, or do
					any kind of I/O, how can we do actual work?
					<aside class="notes">
						We don't live in a purely functional world. Users expect
						to be able to provide input and see corresponding
						output. Things change in real life.
					</aside>
				</section>
				<section>
					Luckily, these are just ideals. Most applications will need
					state, and nearly all will perform some kind of I/O.
					<p class="fragment">
						Our goal with functional programming is to
						<em>minimize</em> state and side effects, and to use
						clever tricks to keep them manageable.
					</p>
					<aside class="notes">
						Basically, we don't. We bend and break the rules, but we
						try to avoid doing so as much as possible.
					</aside>
				</section>
				<section>
					<p>In functional programming, we have 2 clever tricks:</p>
					<ol>
						<li class="fragment">Functions</li>
						<li class="fragment">Fancy Types</li>
					</ol>
				</section>
				<section>
					Using these, we can solve any problem in computer science.
					<aside class="notes">
						Those of you familiar with the lambda calculus will know
						that functions alone are sufficient.
					</aside>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
